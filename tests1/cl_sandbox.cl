typedef double3 t_vec3;typedef double16 t_mat4;typedef double t_real;typedef int t_int;# define VEC(x, y, z)((t_vec3){x, y, z})typedef struct 			s_mat{	t_vec3			diffuse;	t_real			specular;}						t_mat;typedef struct			s_obj{    t_mat				mat;    t_vec3				pos;    t_vec3				rot;    t_real				height;    t_real				radius;}						t_obj;typedef	struct	s_ray {    t_vec3	orig;    t_vec3	dir;    t_real	t;}				t_ray;typedef struct	s_hit {    t_vec3	at;    t_vec3	norm;    __global t_obj	*obj;}				t_hit;t_hit *sphere_inter(        __global t_obj *obj,        __private t_ray *ray,        __private t_hit *hit){    t_vec3 L;    t_real tca;    t_real thc;    t_real t0;    t_real t1;    L = obj->pos - ray->orig;    tca = dot(L, ray->dir);    printf("tca: %f\n", tca);    if (tca < 0)        return (NULL);    thc = dot(L, L) - tca * tca;    if (thc > obj->radius)        return (NULL);    t0 = sqrt(obj->radius - thc);    t1 = tca + t0;    t0 = tca - t0;    if (t1 < 0 && t0 < 0)        return (NULL);    t0 = t0 > t1 && t1 > 0 ? t1 : t0;    hit->at = ray->orig + ray->dir * t0;    hit->norm = normalize(hit->at - obj->pos);    hit->obj = obj;    return (hit);}void pv(double3 v){    printf("------{%f %f %f}------\n", v.x, v.y, v.z);}t_mat4 m4_mul(t_mat4 M, t_mat4 N){    t_mat4 result = (t_mat4){        M.s0 * N.s0 + M.s1 * N.s4 + M.s2 * N.s8 + M.s3 * N.sC,        M.s0 * N.s1 + M.s1 * N.s5 + M.s2 * N.s9 + M.s3 * N.sD,        M.s0 * N.s2 + M.s1 * N.s6 + M.s2 * N.sA + M.s3 * N.sE,        M.s0 * N.s3 + M.s1 * N.s7 + M.s2 * N.sB + M.s3 * N.sF,        M.s4 * N.s0 + M.s5 * N.s4 + M.s6 * N.s8 + M.s7 * N.sC,        M.s4 * N.s1 + M.s5 * N.s5 + M.s6 * N.s9 + M.s7 * N.sD,        M.s4 * N.s2 + M.s5 * N.s6 + M.s6 * N.sA + M.s7 * N.sE,        M.s4 * N.s3 + M.s5 * N.s7 + M.s6 * N.sB + M.s7 * N.sF,        M.s8 * N.s0 + M.s9 * N.s4 + M.sA * N.s8 + M.sB * N.sC,        M.s8 * N.s1 + M.s9 * N.s5 + M.sA * N.s9 + M.sB * N.sD,        M.s8 * N.s2 + M.s9 * N.s6 + M.sA * N.sA + M.sB * N.sE,        M.s8 * N.s3 + M.s9 * N.s7 + M.sA * N.sB + M.sB * N.sF,        M.sC * N.s0 + M.sD * N.s4 + M.sE * N.s8 + M.sF * N.sC,        M.sC * N.s1 + M.sD * N.s5 + M.sE * N.s9 + M.sF * N.sD,        M.sC * N.s2 + M.sD * N.s6 + M.sE * N.sA + M.sF * N.sE,        M.sC * N.s3 + M.sD * N.s7 + M.sE * N.sB + M.sF * N.sF};    return (result);}__kernel void k_render(		uint width,		uint height,		uint size,		__global t_obj* scene,		__global t_vec3* test,		__global char* output){	int id = get_global_id(0);    int x = id % (int)width - width / 2;    int y = id / (int)height - height / 2;    t_ray r = (t_ray){            VEC(x, y, 0),            VEC(0, 0, 1),            100    };    t_hit h;	if (id == 0){	    double3 d31 = (double3){1, 2, 3};    	double3 d32 = (double3){1, 2, 3};        double3 d312 = d31 * d32;        pv(d31);        pv(d32);        pv(d312);        double16 d161 = (double16){            1, 2, 0, 0,            0, 1, 2, 0,            0, 0, 1, 3,            0, 0, 0, 1        };        double16 d162 = (double16){            1, 0, 0, 0,            5, 1, 0, 0,            0, 4, 1, 0,            0, 0, 0, 1        };        m4_mul(d161,d162);        printf("dot: %f\n", dot(d31, d31));		int i = 0;		while (i < size)		{			printf("G %f %f ", scene[i].radius);			i++;		}		printf("\n");		printf("test: 5: %f\n", test[5].x);	}	output[id] = sphere_inter(&scene[0], &r, &h) ? '#' : '.';	// printf("id: %d -> %c\n", id, output[id]);}